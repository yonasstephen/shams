"""Tests for matchup projection logic."""

from __future__ import annotations

from datetime import date
from unittest.mock import Mock, patch

import pytest

from tools.matchup import matchup_projection
from tools.schedule.schedule_fetcher import PlayerSchedule


@pytest.mark.unit
def test_player_is_active_regular_position():
    """Test that player with regular position is active."""
    player = {
        "name": {"full": "Test Player"},
        "selected_position": {"position": "PG"}
    }
    
    assert matchup_projection._player_is_active(player) is True


@pytest.mark.unit
def test_player_is_active_bench():
    """Test that benched player is inactive."""
    player = {
        "name": {"full": "Test Player"},
        "selected_position": {"position": "BN"}
    }
    
    assert matchup_projection._player_is_active(player) is False


@pytest.mark.unit
def test_player_is_active_injured_list():
    """Test that player on IL is inactive."""
    player = {
        "name": {"full": "Test Player"},
        "selected_position": {"position": "IL"}
    }
    
    assert matchup_projection._player_is_active(player) is False


@pytest.mark.unit
def test_player_is_active_injured_list_plus():
    """Test that player on IL+ is inactive."""
    player = {
        "name": {"full": "Test Player"},
        "selected_position": {"position": "IL+"}
    }
    
    assert matchup_projection._player_is_active(player) is False


@pytest.mark.unit
def test_player_is_active_no_position():
    """Test that player with no position is inactive."""
    player = {
        "name": {"full": "Test Player"},
        "selected_position": {"position": ""}
    }
    
    assert matchup_projection._player_is_active(player) is False
    
    player_no_pos = {
        "name": {"full": "Test Player"}
    }
    
    assert matchup_projection._player_is_active(player_no_pos) is False


@pytest.mark.unit
def test_build_player_active_dates(sample_roster):
    """Test building map of player active dates."""
    active_dates = matchup_projection._build_player_active_dates(sample_roster)
    
    # Active players should have their dates recorded
    assert "nba.p.3704" in active_dates  # Giannis (PF)
    assert "nba.p.5432" in active_dates  # Lillard (PG)
    assert "2024-11-01" in active_dates["nba.p.3704"]
    
    # Inactive players should not be in active dates
    assert "nba.p.6789" not in active_dates  # IL player
    assert "nba.p.9876" not in active_dates  # Bench player


@pytest.mark.unit
def test_calculate_projected_points(sample_stat_categories):
    """Test calculating projected team points."""
    team_a_projection = {
        "0": 0.45,  # FG%
        "1": 0.80,  # FT%
        "2": 12.0,  # 3PTM
        "3": 110.0,  # PTS
        "4": 45.0,  # REB
        "5": 28.0,  # AST
        "6": 8.0,  # STL
        "7": 5.0,  # BLK
        "8": 12.0,  # TO (lower is better)
    }
    
    team_b_projection = {
        "0": 0.42,  # FG%
        "1": 0.75,  # FT%
        "2": 10.0,  # 3PTM
        "3": 105.0,  # PTS
        "4": 42.0,  # REB
        "5": 30.0,  # AST
        "6": 7.0,  # STL
        "7": 6.0,  # BLK
        "8": 15.0,  # TO (lower is better)
    }
    
    points_a, points_b = matchup_projection._calculate_projected_points(
        sample_stat_categories,
        team_a_projection,
        team_b_projection
    )
    
    # Team A should win: FG%, FT%, 3PTM, PTS, REB, STL, TO = 7 categories
    # Team B should win: AST, BLK = 2 categories
    assert points_a["win"] == 7.0
    assert points_a["loss"] == 2.0
    assert points_b["win"] == 2.0
    assert points_b["loss"] == 7.0


@pytest.mark.unit
def test_calculate_projected_points_tie():
    """Test calculating projected points with a tie."""
    sample_categories = [
        {"stat_id": "0", "display_name": "PTS", "sort_order": "1", "is_only_display_stat": 0},
        {"stat_id": "1", "display_name": "REB", "sort_order": "1", "is_only_display_stat": 0},
    ]
    
    team_a_projection = {"0": 100.0, "1": 40.0}
    team_b_projection = {"0": 100.0, "1": 45.0}  # Tie in PTS
    
    points_a, points_b = matchup_projection._calculate_projected_points(
        sample_categories,
        team_a_projection,
        team_b_projection
    )
    
    # PTS is tie (0.5 each), REB goes to B
    assert points_a["tie"] == 0.5
    assert points_a["win"] == 0.0
    assert points_a["loss"] == 1.0
    assert points_b["tie"] == 0.5
    assert points_b["win"] == 1.0
    assert points_b["loss"] == 0.0


@pytest.mark.unit
@patch('tools.player.player_fetcher.player_id_lookup')
@patch('tools.boxscore.boxscore_cache.load_player_season_stats')
def test_project_player_stats(mock_load_stats, mock_lookup, sample_stat_categories):
    """Test projecting player stats for game dates."""
    mock_lookup.return_value = 203507  # Giannis
    mock_load_stats.return_value = {
        "fg_pct": 0.574,
        "ft_pct": 0.745,
        "threes": 1.4,
        "points": 31.1,
        "rebounds": 11.8,
        "assists": 6.5,
        "steals": 1.3,
        "blocks": 2.1,
        "turnovers": 3.2
    }
    
    player = {
        "player_key": "nba.p.3704",
        "name": {"full": "Giannis Antetokounmpo"}
    }
    
    game_dates = ["2024-11-01", "2024-11-03", "2024-11-05"]  # 3 games
    
    projected = matchup_projection._project_player_stats(
        "league_key",
        player,
        game_dates,
        sample_stat_categories,
        "2024-25"
    )
    
    # Percentages should not be multiplied
    assert projected["0"] == 0.574  # FG%
    assert projected["1"] == 0.745  # FT%
    
    # Counting stats should be multiplied by games
    assert projected["2"] == 1.4 * 3  # 3PTM
    assert projected["3"] == 31.1 * 3  # PTS
    assert projected["4"] == 11.8 * 3  # REB
    assert projected["5"] == 6.5 * 3  # AST
    assert projected["6"] == 1.3 * 3  # STL
    assert projected["7"] == 2.1 * 3  # BLK
    assert projected["8"] == 3.2 * 3  # TO


@pytest.mark.unit
@patch('tools.player.player_fetcher.player_id_lookup')
def test_project_player_stats_no_nba_id(mock_lookup, sample_stat_categories):
    """Test projecting stats when NBA ID not found."""
    mock_lookup.return_value = None
    
    player = {
        "player_key": "nba.p.unknown",
        "name": {"full": "Unknown Player"}
    }
    
    game_dates = ["2024-11-01"]
    
    projected = matchup_projection._project_player_stats(
        "league_key",
        player,
        game_dates,
        sample_stat_categories,
        "2024-25"
    )
    
    # Should return zeros for all stats
    for stat_id in ["0", "1", "2", "3", "4", "5", "6", "7", "8"]:
        assert projected[stat_id] == 0.0


@pytest.mark.unit
def test_date_range():
    """Test _date_range helper function."""
    start = date(2024, 11, 1)
    end = date(2024, 11, 3)
    
    dates = list(matchup_projection._date_range(start, end))
    
    assert len(dates) == 3
    assert dates[0] == date(2024, 11, 1)
    assert dates[1] == date(2024, 11, 2)
    assert dates[2] == date(2024, 11, 3)


@pytest.mark.unit
def test_stat_sort_order():
    """Test _stat_sort_order helper function."""
    stat_asc = {"sort_order": "0"}
    stat_desc = {"sort_order": "1"}
    stat_invalid = {"sort_order": "invalid"}
    
    assert matchup_projection._stat_sort_order(stat_asc) == 0
    assert matchup_projection._stat_sort_order(stat_desc) == 1
    assert matchup_projection._stat_sort_order(stat_invalid) == 0


@pytest.mark.unit
def test_is_category_desc():
    """Test _is_category_desc helper function."""
    stat_asc_str = {"sort_order": "0"}
    stat_asc_int = {"sort_order": 0}
    stat_asc_word = {"sort_order": "asc"}
    stat_desc = {"sort_order": "1"}
    
    assert matchup_projection._is_category_desc(stat_asc_str) is True
    assert matchup_projection._is_category_desc(stat_asc_int) is True
    assert matchup_projection._is_category_desc(stat_asc_word) is True
    assert matchup_projection._is_category_desc(stat_desc) is False


@pytest.mark.unit
def test_player_key():
    """Test _player_key helper function."""
    player_with_key = {"player_key": "nba.p.3704"}
    player_without_key = {"name": "Test"}
    
    assert matchup_projection._player_key(player_with_key) == "nba.p.3704"
    assert matchup_projection._player_key(player_without_key) is None


@pytest.mark.unit
def test_serialize_team_entry():
    """Test _serialize_team_entry helper function."""
    # Dict format
    team_dict = {"team_key": "nba.l.12345.t.1", "name": "Team A"}
    result = matchup_projection._serialize_team_entry(team_dict)
    assert result == team_dict
    
    # Nested format
    nested = {"team": {"team_key": "nba.l.12345.t.1", "name": "Team A"}}
    result = matchup_projection._serialize_team_entry(nested)
    assert result["team_key"] == "nba.l.12345.t.1"


@pytest.mark.unit
def test_ensure_team_key():
    """Test _ensure_team_key helper function."""
    # String
    assert matchup_projection._ensure_team_key("nba.l.12345.t.1") == "nba.l.12345.t.1"
    
    # Bytes
    assert matchup_projection._ensure_team_key(b"nba.l.12345.t.1") == "nba.l.12345.t.1"
    
    # None
    assert matchup_projection._ensure_team_key(None) is None
    
    # Other type
    assert matchup_projection._ensure_team_key(12345) is None


# ============================================================================
# Integration Tests for Roster Contributions vs Remaining Projections
# ============================================================================
# These tests validate the critical separation between current contributions
# (actual stats accumulated) and remaining projections (future expected stats).
# 
# To run these tests:
#   cd tools/tests && pipenv run pytest test_matchup_projection.py::TestRosterContributionsVsProjections -v
#
# To run with coverage:
#   cd tools/tests && pipenv run pytest test_matchup_projection.py --cov=tools.matchup.matchup_projection
# ============================================================================


def create_mock_roster_entry(player_key: str, name: str, position: str) -> dict:
    """Create a single roster entry."""
    return {
        "player_key": player_key,
        "name": {"full": name},
        "selected_position": {"position": position}
    }


def create_mock_schedule(player_nba_id: int, game_dates: list) -> dict:
    """Build schedule response for a player."""
    return {player_nba_id: game_dates}


def create_mock_boxscore(player_nba_id: int, date_str: str, stats: dict) -> tuple:
    """
    Build boxscore response key-value pair.
    
    Args:
        player_nba_id: NBA player ID
        date_str: Date string
        stats: Dict with stat values (points, rebounds, assists, etc.)
        
    Returns:
        Tuple of ((player_id, date), stats_dict)
    """
    return ((player_nba_id, date_str), stats)


def create_mock_season_stats(
    points: float = 20.0,
    rebounds: float = 8.0,
    assists: float = 5.0,
    steals: float = 1.0,
    blocks: float = 1.0,
    turnovers: float = 2.0,
    threes: float = 2.0,
    fg_pct: float = 0.45,
    ft_pct: float = 0.80,
) -> dict:
    """Create season stats dict with defaults."""
    return {
        "games_played": 10,
        "points": points,
        "rebounds": rebounds,
        "assists": assists,
        "steals": steals,
        "blocks": blocks,
        "turnovers": turnovers,
        "threes": threes,
        "fg_pct": fg_pct,
        "ft_pct": ft_pct,
        "fgm": points / 2.2,  # Approximate
        "fga": points / 2.2 / fg_pct if fg_pct > 0 else 0,
        "ftm": points * 0.2,
        "fta": points * 0.2 / ft_pct if ft_pct > 0 else 0,
    }


def assert_contribution_separation(
    result: dict,
    player_key: str,
    expected_current_games: int,
    expected_remaining_games: int,
    expected_total_games: int,
    expected_on_roster_today: bool,
    check_current_nonzero: bool = False,
    check_remaining_nonzero: bool = False,
):
    """
    Assert that current and remaining contributions are properly separated.
    
    Args:
        result: Result from project_matchup()
        player_key: Player to check
        expected_current_games: Expected games_played count
        expected_remaining_games: Expected remaining_games count
        expected_total_games: Expected total_games count
        expected_on_roster_today: Expected is_on_roster_today value
        check_current_nonzero: If True, assert current stats > 0
        check_remaining_nonzero: If True, assert remaining stats > 0
    """
    # Find player in current contributions
    current_contribs = result.get("current_player_contributions", [])
    current_player = None
    for contrib in current_contribs:
        if contrib["player_key"] == player_key:
            current_player = contrib
            break
    
    # Find player in remaining projections
    remaining_contribs = result.get("player_contributions", [])
    remaining_player = None
    for contrib in remaining_contribs:
        if contrib["player_key"] == player_key:
            remaining_player = contrib
            break
    
    # Assert games counts
    if current_player:
        assert current_player["games_played"] == expected_current_games, \
            f"Expected {expected_current_games} games_played, got {current_player['games_played']}"
        assert current_player["total_games"] == expected_total_games, \
            f"Expected {expected_total_games} total_games, got {current_player['total_games']}"
        assert current_player["is_on_roster_today"] == expected_on_roster_today, \
            f"Expected is_on_roster_today={expected_on_roster_today}, got {current_player['is_on_roster_today']}"
        
        if check_current_nonzero:
            # Check that at least one stat is non-zero
            has_stats = any(v > 0 for v in current_player.get("stats", {}).values())
            assert has_stats, f"Expected non-zero current stats for {player_key}"
    
    if remaining_player:
        assert remaining_player["remaining_games"] == expected_remaining_games, \
            f"Expected {expected_remaining_games} remaining_games, got {remaining_player['remaining_games']}"
        assert remaining_player["total_games"] == expected_total_games, \
            f"Expected {expected_total_games} total_games, got {remaining_player['total_games']}"
        assert remaining_player["is_on_roster_today"] == expected_on_roster_today, \
            f"Expected is_on_roster_today={expected_on_roster_today}, got {remaining_player['is_on_roster_today']}"
        
        if check_remaining_nonzero:
            # Check that at least one stat is non-zero
            has_stats = any(v > 0 for v in remaining_player.get("stats", {}).values())
            assert has_stats, f"Expected non-zero remaining stats for {player_key}"


@pytest.mark.integration
class TestRosterContributionsVsProjections:
    """
    Comprehensive integration tests for roster contributions vs remaining projections.
    
    These tests validate the entire matchup projection flow by:
    - Setting up a pool of 6 players with different roster scenarios
    - Creating rosters that change daily to simulate real-world situations
    - Testing all edge cases in a single comprehensive test
    
    Week structure:
    - Week: Mon 2024-11-04 to Sun 2024-11-10
    - Today: Wed 2024-11-06 (day 3 of 7)
    - Past: Mon 2024-11-04, Tue 2024-11-05 (2 days with boxscores)
    - Future: Thu 2024-11-07, Fri 2024-11-08, Sat 2024-11-09, Sun 2024-11-10 (4 days projected)
    
    Player Pool (testing different scenarios):
    - Player A: Active all week, games Mon(past), Wed(today+boxscore), Fri(future)
    - Player B: Added today, game Wed(today, no boxscore)
    - Player C: Active Mon-Tue, dropped Wed
    - Player D: Benched Mon-Tue, activated Wed
    - Player E: Active Mon-Tue, moved to IL on Wed
    - Player F: On IL entire week
    - Player G: Added today but placed on bench (BN)
    """
    
    @pytest.mark.integration
    def test_comprehensive_matchup_scenarios(
        self,
        sample_stat_categories,
        mock_boxscore_cache_setup,
    ):
        """Test scenario 1: Player added today after game already started.
        
        This test validates that when a player is added to the roster after
        a game has already started/finished, they should not receive credit
        for that game in their current contributions.
        """
        from datetime import date
        from tools.matchup import matchup_projection
        from tools.schedule.schedule_fetcher import PlayerSchedule
        
        week_start_str, week_end_str, today_str = mock_week_dates
        today = date.fromisoformat(today_str)
        
        # Setup: Player added today (2024-11-06), has game today that already finished
        player_key = "nba.p.12345"
        player_nba_id = 203507
        
        # Mock Yahoo API - roster collection
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = lambda team, date_str: {
            "roster": {
                "players": [create_mock_roster_entry(player_key, "Test Player", "PG")]
                if date_str >= today else []
            }
        }
        
        # Mock player lookup
        mock_player_lookup.return_value = player_nba_id
        
        # Mock schedule - player has game today
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=[today])
        
        # Mock boxscore - game today already has boxscore (game finished)
        mock_boxscore.return_value = {
            "points": 25, "rebounds": 8, "assists": 5,
            "steals": 2, "blocks": 1, "turnovers": 3,
            "threes": 3, "fgm": 10, "fga": 20, "fg_pct": 0.5,
            "ftm": 5, "fta": 6, "ft_pct": 0.833,
        }
        
        # Mock season stats
        mock_season_stats.return_value = create_mock_season_stats()
        
        # Mock matchup data
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        # Execute
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Player added after game started should have zero contribution
        # Because they were not on roster at game start
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=0,
            expected_remaining_games=0,
            expected_total_games=1,
            expected_on_roster_today=True,
            check_current_nonzero=False,
            check_remaining_nonzero=False,
        )


# ============================================================================
# Functional Integration Tests - Testing Core Logic with Proper Mocks
# ============================================================================

@pytest.mark.integration
class TestRosterContributionsLogic:
    """
    Simplified integration tests focusing on core contribution logic.
    These tests directly test internal functions with proper mocking.
    """
    
    @pytest.mark.integration
    def test_aggregate_current_week_contributions_with_boxscore(self):
        """Test that current contributions correctly aggregate boxscore data."""
        from datetime import date
        from tools.matchup import matchup_projection
        mock_season_stats.return_value = create_mock_season_stats()
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Benched player should have zero contribution/projection
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=0,
            expected_remaining_games=0,
            expected_total_games=3,
            expected_on_roster_today=True,
            check_current_nonzero=False,
            check_remaining_nonzero=False,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_player_dropped_after_contributing(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 3: Player dropped after contributing yesterday."""
        week_start, week_end, today = mock_week_dates
        yesterday = "2024-11-05"
        
        player_key = "nba.p.12347"
        player_nba_id = 203509
        
        # Mock roster - player was active yesterday, not on roster today
        def get_roster(team, date_str):
            if date_str < today:
                return {
                    "roster": {
                        "players": [create_mock_roster_entry(player_key, "Dropped Player", "SG")]
                    }
                }
            return {"roster": {"players": []}}
        
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = get_roster
        
        mock_player_lookup.return_value = player_nba_id
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=[yesterday, today, "2024-11-08"])
        
        # Mock boxscore for yesterday's game
        def get_boxscore(player_id, date_str):
            if date_str == yesterday:
                return {
                    "points": 30, "rebounds": 10, "assists": 7,
                    "steals": 2, "blocks": 1, "turnovers": 2,
                    "threes": 4, "fgm": 12, "fga": 22, "fg_pct": 0.545,
                    "ftm": 6, "fta": 8, "ft_pct": 0.75,
                }
            return None
        
        mock_boxscore.side_effect = get_boxscore
        mock_season_stats.return_value = create_mock_season_stats(points=25.0)
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Dropped player should have contribution from yesterday,
        # but no remaining projection, and is_on_roster_today=False
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=1,
            expected_remaining_games=0,
            expected_total_games=3,
            expected_on_roster_today=False,
            check_current_nonzero=True,
            check_remaining_nonzero=False,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_player_active_entire_week(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 4: Player active entire week with past and future games."""
        week_start, week_end, today = mock_week_dates
        
        player_key = "nba.p.12348"
        player_nba_id = 203510
        
        # Mock roster - player active all week
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = lambda team, date_str: {
            "roster": {
                "players": [create_mock_roster_entry(player_key, "Star Player", "SF")]
            }
        }
        
        mock_player_lookup.return_value = player_nba_id
        
        # Games on Mon, Tue (past), Thu, Sat (future)
        past_games = ["2024-11-04", "2024-11-05"]
        future_games = ["2024-11-07", "2024-11-09"]
        all_games = past_games + future_games
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=all_games)
        
        # Mock boxscores for past games
        def get_boxscore(player_id, date_str):
            if date_str in past_games:
                return {
                    "points": 22, "rebounds": 7, "assists": 6,
                    "steals": 1, "blocks": 1, "turnovers": 2,
                    "threes": 2, "fgm": 9, "fga": 18, "fg_pct": 0.5,
                    "ftm": 4, "fta": 5, "ft_pct": 0.8,
                }
            return None
        
        mock_boxscore.side_effect = get_boxscore
        mock_season_stats.return_value = create_mock_season_stats(points=22.0, rebounds=7.0, assists=6.0)
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Should have contribution from 2 past games, projection for 2 future games
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=2,
            expected_remaining_games=2,
            expected_total_games=4,
            expected_on_roster_today=True,
            check_current_nonzero=True,
            check_remaining_nonzero=True,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_player_moved_from_bench_to_active(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 5: Player moved from bench to active mid-week."""
        week_start, week_end, today = mock_week_dates
        
        player_key = "nba.p.12349"
        player_nba_id = 203511
        
        # Mock roster - benched Mon-Tue, active from Wed onwards
        def get_roster(team, date_str):
            if date_str >= today:
                position = "PF"
            else:
                position = "BN"
            return {
                "roster": {
                    "players": [create_mock_roster_entry(player_key, "Activated Player", position)]
                }
            }
        
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = get_roster
        
        mock_player_lookup.return_value = player_nba_id
        
        # Games on Mon (benched), Thu, Sat (active)
        all_games = ["2024-11-04", "2024-11-07", "2024-11-09"]
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=all_games)
        
        mock_boxscore.return_value = None
        mock_season_stats.return_value = create_mock_season_stats()
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Only future games (Thu, Sat) should count, not Mon game when benched
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=0,
            expected_remaining_games=2,
            expected_total_games=3,
            expected_on_roster_today=True,
            check_current_nonzero=False,
            check_remaining_nonzero=True,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_player_game_today_not_played(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 6: Player with game today that hasn't been played yet."""
        week_start, week_end, today = mock_week_dates
        
        player_key = "nba.p.12350"
        player_nba_id = 203512
        
        # Mock roster - player active all week
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = lambda team, date_str: {
            "roster": {
                "players": [create_mock_roster_entry(player_key, "Today Player", "C")]
            }
        }
        
        mock_player_lookup.return_value = player_nba_id
        
        # Games on Tue (past), Wed (today), Fri (future)
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=["2024-11-05", today, "2024-11-08"])
        
        # Mock boxscore - only Tue has boxscore, today's game not yet played
        def get_boxscore(player_id, date_str):
            if date_str == "2024-11-05":
                return {
                    "points": 18, "rebounds": 12, "assists": 2,
                    "steals": 1, "blocks": 3, "turnovers": 1,
                    "threes": 0, "fgm": 8, "fga": 14, "fg_pct": 0.571,
                    "ftm": 2, "fta": 4, "ft_pct": 0.5,
                }
            return None
        
        mock_boxscore.side_effect = get_boxscore
        mock_season_stats.return_value = create_mock_season_stats(points=18.0, rebounds=12.0)
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Today's game should be in remaining projection (not current)
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=1,  # Only Tue
            expected_remaining_games=2,  # Wed (today) + Fri
            expected_total_games=3,
            expected_on_roster_today=True,
            check_current_nonzero=True,
            check_remaining_nonzero=True,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_player_game_today_already_played(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 7: Player with game today that has already been played."""
        week_start, week_end, today = mock_week_dates
        
        player_key = "nba.p.12351"
        player_nba_id = 203513
        
        # Mock roster - player active all week
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = lambda team, date_str: {
            "roster": {
                "players": [create_mock_roster_entry(player_key, "Today Played", "PG")]
            }
        }
        
        mock_player_lookup.return_value = player_nba_id
        
        # Games on Tue (past), Wed (today), Fri (future)
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=["2024-11-05", today, "2024-11-08"])
        
        # Mock boxscore - both Tue and today have boxscores
        def get_boxscore(player_id, date_str):
            if date_str in ["2024-11-05", today]:
                return {
                    "points": 24, "rebounds": 4, "assists": 9,
                    "steals": 2, "blocks": 0, "turnovers": 3,
                    "threes": 3, "fgm": 9, "fga": 19, "fg_pct": 0.474,
                    "ftm": 6, "fta": 7, "ft_pct": 0.857,
                }
            return None
        
        mock_boxscore.side_effect = get_boxscore
        mock_season_stats.return_value = create_mock_season_stats(points=24.0, assists=9.0)
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Today's game should be in current (not remaining)
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=2,  # Tue + Wed (today)
            expected_remaining_games=1,  # Only Fri
            expected_total_games=3,
            expected_on_roster_today=True,
            check_current_nonzero=True,
            check_remaining_nonzero=True,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_player_moved_to_il_midweek(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 8: Player moved to IL mid-week."""
        week_start, week_end, today = mock_week_dates
        
        player_key = "nba.p.12352"
        player_nba_id = 203514
        
        # Mock roster - active Mon-Tue, IL from Wed onwards
        def get_roster(team, date_str):
            if date_str >= today:
                position = "IL"
            else:
                position = "SG"
            return {
                "roster": {
                    "players": [create_mock_roster_entry(player_key, "Injured Player", position)]
                }
            }
        
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = get_roster
        
        mock_player_lookup.return_value = player_nba_id
        
        # Games on Mon, Wed, Sat
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=["2024-11-04", today, "2024-11-09"])
        
        # Mock boxscore for Mon game
        def get_boxscore(player_id, date_str):
            if date_str == "2024-11-04":
                return {
                    "points": 15, "rebounds": 5, "assists": 3,
                    "steals": 1, "blocks": 0, "turnovers": 2,
                    "threes": 2, "fgm": 6, "fga": 12, "fg_pct": 0.5,
                    "ftm": 3, "fta": 4, "ft_pct": 0.75,
                }
            return None
        
        mock_boxscore.side_effect = get_boxscore
        mock_season_stats.return_value = create_mock_season_stats(points=15.0)
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Only contribution from Mon, no remaining projection
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=1,
            expected_remaining_games=0,
            expected_total_games=3,
            expected_on_roster_today=True,
            check_current_nonzero=True,
            check_remaining_nonzero=False,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_newly_added_player_with_future_games(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 9: Newly added player (yesterday) with future games."""
        week_start, week_end, today = mock_week_dates
        yesterday = "2024-11-05"
        
        player_key = "nba.p.12353"
        player_nba_id = 203515
        
        # Mock roster - player added yesterday
        def get_roster(team, date_str):
            if date_str >= yesterday:
                return {
                    "roster": {
                        "players": [create_mock_roster_entry(player_key, "New Pickup", "SF")]
                    }
                }
            return {"roster": {"players": []}}
        
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = get_roster
        
        mock_player_lookup.return_value = player_nba_id
        
        # Games on Mon (before pickup), Wed, Fri, Sun
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=["2024-11-04", today, "2024-11-08", "2024-11-10"])
        
        # Mock boxscore for yesterday's game (added after game)
        def get_boxscore(player_id, date_str):
            if date_str == yesterday:
                return {
                    "points": 20, "rebounds": 6, "assists": 4,
                    "steals": 1, "blocks": 1, "turnovers": 2,
                    "threes": 2, "fgm": 8, "fga": 15, "fg_pct": 0.533,
                    "ftm": 4, "fta": 5, "ft_pct": 0.8,
                }
            return None
        
        mock_boxscore.side_effect = get_boxscore
        mock_season_stats.return_value = create_mock_season_stats(points=20.0)
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Zero/minimal current (not on roster for Mon game),
        # full projection for future games (Wed, Fri, Sun)
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=0,  # Added after games started
            expected_remaining_games=3,  # Wed, Fri, Sun
            expected_total_games=4,
            expected_on_roster_today=True,
            check_current_nonzero=False,
            check_remaining_nonzero=True,
        )
    
    @pytest.mark.integration
    @patch('tools.matchup.matchup_projection.yahoo')
    @patch('tools.boxscore.boxscore_cache.load_player_boxscore')
    @patch('tools.boxscore.boxscore_cache.load_player_season_stats')
    @patch('tools.schedule.schedule_fetcher.fetch_player_upcoming_games_from_cache')
    @patch('tools.player.player_fetcher.player_id_lookup')
    def test_player_on_il_entire_week(
        self,
        mock_player_lookup,
        mock_schedule,
        mock_season_stats,
        mock_boxscore,
        mock_yahoo,
        mock_week_dates,
        sample_stat_categories,
    ):
        """Test scenario 10: Player on IL entire week."""
        week_start, week_end, today = mock_week_dates
        
        player_key = "nba.p.12354"
        player_nba_id = 203516
        
        # Mock roster - player on IL all week
        mock_yahoo.return_value.get_team_roster_for_date.side_effect = lambda team, date_str: {
            "roster": {
                "players": [create_mock_roster_entry(player_key, "Injured All Week", "IL+")]
            }
        }
        
        mock_player_lookup.return_value = player_nba_id
        mock_schedule.return_value = PlayerSchedule(player_id=player_nba_id, game_dates=["2024-11-04", today, "2024-11-08"])
        mock_boxscore.return_value = None
        mock_season_stats.return_value = create_mock_season_stats()
        
        mock_yahoo.return_value.get_matchup_for_week.return_value = {
            "matchup": {
                "week": "3",
                "week_start": week_start,
                "week_end": week_end,
                "teams": [
                    {"team_key": "nba.l.12345.t.1", "name": "Test Team"},
                    {"team_key": "nba.l.12345.t.2", "name": "Opponent Team"}
                ]
            }
        }
        
        mock_yahoo.return_value.get_league_settings.return_value = {
            "league": {
                "league_key": "nba.l.12345",
                "current_week": "3",
                "season": "2024-25",
                "stat_categories": {"stats": {"stat": sample_stat_categories}}
            }
        }
        
        result = matchup_projection.project_matchup(
            "nba.l.12345",
            "nba.l.12345.t.1",
            week=3,
            today=today
        )
        
        # Assert: Zero contribution and zero projection
        assert_contribution_separation(
            result,
            player_key,
            expected_current_games=0,
            expected_remaining_games=0,
            expected_total_games=3,
            expected_on_roster_today=True,
            check_current_nonzero=False,
            check_remaining_nonzero=False,
        )


# ============================================================================
# Functional Integration Tests - Testing Core Logic with Proper Mocks
# ============================================================================

@pytest.mark.integration
class TestRosterContributionsLogic:
    """
    Simplified integration tests focusing on core contribution logic.
    These tests directly test internal functions with proper mocking.
    """
    
    @pytest.mark.integration
    def test_aggregate_current_week_contributions_with_boxscore(self):
        """Test that current contributions correctly aggregate boxscore data."""
        from datetime import date
        from tools.matchup import matchup_projection
        
        # Setup: Create a simple roster with one player active on one date
        roster = {
            "2024-11-05": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ]
        }
        
        stat_meta = [
            {"stat_id": "12", "display_name": "PTS", "name": "Points", "is_only_display_stat": 0},
            {"stat_id": "15", "display_name": "REB", "name": "Rebounds", "is_only_display_stat": 0},
        ]
        
        week_start = date(2024, 11, 4)
        week_end = date(2024, 11, 10)
        today = date(2024, 11, 6)
        
        # Mock player lookup
        with patch('tools.matchup.matchup_projection.player_fetcher.player_id_lookup', return_value=203507):
            # Mock fetch_player_stats_from_cache to return a game
            with patch('tools.matchup.matchup_projection.player_fetcher.fetch_player_stats_from_cache') as mock_fetch:
                mock_fetch.return_value = [
                    {
                        "date": "2024-11-05",
                        "PTS": 25.0,
                        "REB": 10.0,
                        "Points": 25.0,
                        "Rebounds": 10.0,
                        "FGM": 10,
                        "FGA": 20,
                        "FTM": 5,
                        "FTA": 6,
                    }
                ]
                
                # Execute
                contributions, player_names, player_shooting, is_on_roster, games_played = \
                    matchup_projection._aggregate_current_week_player_contributions(
                        "test_league",
                        roster,
                        week_start,
                        week_end,
                        stat_meta,
                        season="2024-25"
                    )
                
                # Assert
                assert "nba.p.12345" in contributions
                assert contributions["nba.p.12345"]["12"] == 25.0  # Points
                assert contributions["nba.p.12345"]["15"] == 10.0  # Rebounds
                assert games_played["nba.p.12345"] == 1
                assert player_names["nba.p.12345"] == "Test Player"
    
    @pytest.mark.integration  
    def test_aggregate_projected_contributions_excludes_today_with_boxscore(self):
        """Test that remaining projections exclude today if boxscore exists."""
        from datetime import date
        from tools.matchup import matchup_projection
        from tools.schedule.schedule_fetcher import PlayerSchedule
        
        # Setup - Player must be on roster for all dates they'll have games
        roster = {
            "2024-11-05": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
            "2024-11-06": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
            "2024-11-07": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
            "2024-11-08": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
        }
        
        stat_meta = [
            {"stat_id": "12", "display_name": "PTS", "name": "Points", "is_only_display_stat": 0},
        ]
        
        week_start = date(2024, 11, 4)
        week_end = date(2024, 11, 10)
        today = date(2024, 11, 6)
        
        # Mock dependencies
        with patch('tools.matchup.matchup_projection.player_fetcher.player_id_lookup', return_value=203507):
            with patch('tools.matchup.matchup_projection.schedule_fetcher.fetch_player_upcoming_games_from_cache') as mock_schedule:
                # Player has games on 2024-11-05, 2024-11-06 (today), and 2024-11-08
                mock_schedule.return_value = PlayerSchedule(
                    player_id=203507,
                    game_dates=["2024-11-05", "2024-11-06", "2024-11-08"]
                )
                
                with patch('tools.matchup.matchup_projection.boxscore_cache.load_player_games') as mock_load_games:
                    # Boxscore exists for 2024-11-05 AND 2024-11-06 (today)
                    mock_load_games.return_value = {
                        "player_id": 203507,
                        "player_name": "Test Player",
                        "games": [
                            {"date": "2024-11-05", "PTS": 25.0},
                            {"date": "2024-11-06", "PTS": 20.0},  # Today has boxscore
                        ]
                    }
                    
                    with patch('tools.matchup.matchup_projection.boxscore_cache.load_player_season_stats') as mock_season:
                        mock_season.return_value = {
                            "points": 22.0,
                            "fgm": 9.0,
                            "fga": 20.0,
                            "ftm": 4.0,
                            "fta": 5.0,
                            "fg_pct": 0.45,
                            "ft_pct": 0.80,
                        }
                        
                        # Execute - Mock date.today() to control "today" in the function
                        with patch('tools.matchup.matchup_projection.date') as mock_date_class:
                            mock_date_class.today.return_value = today
                            mock_date_class.side_effect = lambda *args, **kw: date(*args, **kw)
                            contributions, player_names, total_games, remaining_games, shooting, daily, positions = \
                                matchup_projection._aggregate_projected_contributions(
                                    "test_league",
                                    roster,
                                    week_start,
                                    week_end,
                                    stat_meta,
                                    season="2024-25"
                                )
                        
                        # Assert: Today (2024-11-06) should be EXCLUDED from remaining since boxscore exists
                        # Only 2024-11-08 should count as remaining
                        assert "nba.p.12345" in remaining_games
                        assert remaining_games["nba.p.12345"] == 1, \
                            f"Expected 1 remaining game (only 2024-11-08), got {remaining_games['nba.p.12345']}"
                        
                        # Total games should be 3
                        assert total_games["nba.p.12345"] == 3
    
    @pytest.mark.integration
    def test_aggregate_projected_contributions_includes_today_without_boxscore(self):
        """Test that remaining projections include today if no boxscore exists."""
        from datetime import date
        from tools.matchup import matchup_projection
        from tools.schedule.schedule_fetcher import PlayerSchedule
        
        # Setup - Player must be on roster for all dates they'll have games
        roster = {
            "2024-11-05": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
            "2024-11-06": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
            "2024-11-07": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
            "2024-11-08": [
                {
                    "player_key": "nba.p.12345",
                    "name": {"full": "Test Player"},
                    "selected_position": {"position": "PG"}
                }
            ],
        }
        
        stat_meta = [
            {"stat_id": "12", "display_name": "PTS", "name": "Points", "is_only_display_stat": 0},
        ]
        
        week_start = date(2024, 11, 4)
        week_end = date(2024, 11, 10)
        today = date(2024, 11, 6)
        
        # Mock dependencies
        with patch('tools.matchup.matchup_projection.player_fetcher.player_id_lookup', return_value=203507):
            with patch('tools.matchup.matchup_projection.schedule_fetcher.fetch_player_upcoming_games_from_cache') as mock_schedule:
                # Player has games on 2024-11-05, 2024-11-06 (today), and 2024-11-08
                mock_schedule.return_value = PlayerSchedule(
                    player_id=203507,
                    game_dates=["2024-11-05", "2024-11-06", "2024-11-08"]
                )
                
                with patch('tools.matchup.matchup_projection.boxscore_cache.load_player_games') as mock_load_games:
                    # Boxscore exists for 2024-11-05 but NOT for 2024-11-06 (today)
                    mock_load_games.return_value = {
                        "player_id": 203507,
                        "player_name": "Test Player",
                        "games": [
                            {"date": "2024-11-05", "PTS": 25.0},
                            # No game for 2024-11-06 - game hasn't been played yet
                        ]
                    }
                    
                    with patch('tools.matchup.matchup_projection.boxscore_cache.load_player_season_stats') as mock_season:
                        mock_season.return_value = {
                            "points": 22.0,
                            "fgm": 9.0,
                            "fga": 20.0,
                            "ftm": 4.0,
                            "fta": 5.0,
                            "fg_pct": 0.45,
                            "ft_pct": 0.80,
                        }
                        
                        # Execute - Mock date.today() to control "today" in the function
                        with patch('tools.matchup.matchup_projection.date') as mock_date_class:
                            mock_date_class.today.return_value = today
                            mock_date_class.side_effect = lambda *args, **kw: date(*args, **kw)
                            contributions, player_names, total_games, remaining_games, shooting, daily, positions = \
                                matchup_projection._aggregate_projected_contributions(
                                    "test_league",
                                    roster,
                                    week_start,
                                    week_end,
                                    stat_meta,
                                    season="2024-25"
                                )
                        
                        # Assert: Today (2024-11-06) should be INCLUDED in remaining since no boxscore
                        # Both 2024-11-06 and 2024-11-08 should count
                        assert "nba.p.12345" in remaining_games
                        assert remaining_games["nba.p.12345"] == 2, \
                            f"Expected 2 remaining games (2024-11-06 and 2024-11-08), got {remaining_games['nba.p.12345']}"
                        
                        # Total games should be 3
                        assert total_games["nba.p.12345"] == 3

